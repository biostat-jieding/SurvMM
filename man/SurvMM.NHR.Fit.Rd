% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Functions.R
\name{SurvMM.NHR.Fit}
\alias{SurvMM.NHR.Fit}
\title{Nonparametric Mixture Modeling of Survival Data}
\usage{
SurvMM.NHR.Fit(
  yobs,
  delta,
  X,
  xGrids = NULL,
  parx.init = NULL,
  numG = 2,
  cure = FALSE,
  bandwidth = list(h = seq(0.03, 0.21, by = 0.03), nfold = 5),
  kern = "Epanechnikov",
  porder = c(0, 5, 0),
  boots = list(do = TRUE, nboot = 100),
  GoF = list(do = TRUE, siglevel = 0.05),
  error = "extreme",
  maxit = 80,
  maxit.step = 5,
  eps = 1e-05,
  trace = TRUE
)
}
\arguments{
\item{yobs}{time to event of interest.}

\item{delta}{the censoring indicator, normally 1 = event of interest happens, and 0 = censoring.}

\item{X}{a matrix of covariates.}

\item{xGrids}{the grid points of fitting over the range of interested covariate.}

\item{parx.init}{the initial value of functional curves. The default is NULL.}

\item{numG}{the number of latent groups.}

\item{cure}{a logical value that indicates whether a cured latent group should be included.}

\item{bandwidth}{a list that specifies information concerning bandwidth. It contains two elements:
\code{h} the candidate set of bandwidths;
\code{nfold} the number of cross-validation folds.}

\item{kern}{the kernal function. The default is Epanechnikov kernel.}

\item{porder}{the order of polynomial regressions for initial values.}

\item{boots}{a list that specifies information concerning bandwidth. It contains two elements:
\code{do} whether the bootstrap procedure should be conducted;
\code{nboot} specifies the number of bootstrap sampling.}

\item{GoF}{a list that specifies information concerning bandwidth. It contains two elements:
\code{do} whether the goodness-of-fit test statistic should be calculated;
\code{siglevel} the significance level of testing.}

\item{error}{distribution function of error term}

\item{maxit}{the maximum number of iteration.}

\item{maxit.step}{the maximum number of iteration before likelihood increasing.}

\item{eps}{the error of convergence.}

\item{trace}{a logical to indicate whether the traces of model fitting should be printed.}
}
\description{
Fit the finite mixture model that is composed of non-parametric heteroscedastic regression models.
}
\details{
This is a function used to fit nonparametric mixture survival model based on the local likelihood technique.
}
\examples{
\donttest{

#------------------------------------------------------------------------#
# Illustration based on a simulated dataset ####
#------------------------------------------------------------------------#

# generate the used dataset (a mixture of two latent groups)

# - true functional curves
parx.true <- list(
  px = function(x){c(0.2+0.4*sin(pi*x),0.8-0.4*sin(pi*x))},
  mx = function(x){c(2-0.5*sin(2*pi*x),0.5*cos(2*pi*x))},
  sx = function(x){c(0.4*exp(0.4*x^2),0.3*exp(-0.2*x))}
)

# - generate the survival dataset and extract elements
set.seed(1)
sdata <- sdata.generate(N=500,parx=parx.true,cvalue=12)
yobs <- sdata$yobs
delta <- sdata$delta
X    <- as.matrix(sdata[,-c(1,2),drop=FALSE])

# model fitting and do visualization

# - fit the model via defined function
xGrids <- seq(0,1,0.01)
sol.FMM.NHR <- SurvMM.NHR.Fit(
  yobs      = yobs,
  delta     = delta,
  X         = X,
  xGrids    = xGrids,
  numG      = 2,
  bandwidth = list(
    h       = seq(0.03,0.21,0.03),
    nfold   = 5),
  porder    = c(0,3,0),
  boots     = list(do = FALSE, nboot = NULL),
  GoF       = list(do = FALSE, siglevel = NULL)
)

# - extract fitted functional curves
parx <- sol.FMM.NHR$parx

# do plot

# - preparation
par(mfrow=c(1,3))

# - plot fitted regression function
# __ for observed data points
plot(
  log(yobs[delta==1])~X[delta==1,],
  type="p",pch=16,cex=0.3,
  xlim=c(0,1),ylim=c(-3,3),
  xlab="x",ylab="Logarithm of Survival Time",
  main="Regression Function"
)
# __ proposed estimates
lines(parx$mx[,1]~xGrids,lty="dotdash",col="blue",lwd=2)
lines(parx$mx[,2]~xGrids,lty="dotdash",col="blue",lwd=2)
# __ true estimates
lines(sapply(xGrids,parx.true$mx)[1,]~xGrids)
lines(sapply(xGrids,parx.true$mx)[2,]~xGrids)

# - plot fitted mixing proportion function
# __ true estimates
plot(
  sapply(xGrids,parx.true$px)[1,]~xGrids,
  type="l",lwd=2,
  xlim=c(0,1),ylim=c(0,1),
  xlab="x",ylab="Mixing Probability",
  main="Mixing Probability Function"
)
lines(sapply(xGrids,parx.true$px)[2,]~xGrids,lwd=2)
# __ proposed estimates
lines(parx$px[,1]~xGrids,lty="dotdash",col="blue",lwd=2)
lines(parx$px[,2]~xGrids,lty="dotdash",col="blue",lwd=2)


# - plot fitted standard error function
# __ true estimates
plot(
  sapply(xGrids,parx.true$sx)[1,]~xGrids,
  type="l",lwd=2,
  xlim=c(0,1),ylim=c(0.2,0.7),
  xlab="x",ylab="Variance of Error Term",
  main="Variance Function"
)
lines(sapply(xGrids,parx.true$sx)[2,]~xGrids,lwd=2)
# __ proposed estimates
lines(parx$sx[,1]~xGrids,lty="dotdash",col="blue",lwd=2)
lines(parx$sx[,2]~xGrids,lty="dotdash",col="blue",lwd=2)

}

}
